[tools]
node = "22.14.0"
ruby = "3.4.3"

# Environment variables for development
[env]
ENABLE_DEFAULT_OTP = "true"
AWS_REGION = "us-east-1"
AWS_ACCESS_KEY_ID = "minioadmin"
AWS_SECRET_ACCESS_KEY = "minioadmin123"
AWS_ENDPOINT_URL = "http://localhost:9000"
S3_PRIVATE_BUCKET = "flexile-development-private"
S3_PUBLIC_BUCKET = "flexile-development-public"
DOCUSEAL_TOKEN = "dummy"
QUICKBOOKS_WEBHOOK_SECRET = "dummy"
RESEND_API_KEY = "dummy"
API_SECRET_TOKEN = "sample-api-token"
NEXTAUTH_SECRET = "sample-nextauth-secret"
RAILS_ENV = "development"
NODE_ENV = "development"

# === MAIN DEVELOPMENT TASKS ===

[tasks.setup]
alias = "install"
description = "ğŸš€ Complete project setup - replaces bin/setup"
run = """
#!/usr/bin/env bash
set -e
echo "ğŸš€ Setting up Flexile development environment..."

# Check prerequisites
if ! command -v docker &> /dev/null; then
  echo "âŒ Docker not found. Please install Docker first."
  exit 1
fi

# Install dependencies
echo "ğŸ“¦ Installing dependencies..."
corepack enable
cd backend && bundle install && gem install foreman && cd ..
cd frontend && pnpm install && cd ..

# Setup environment
echo "âš™ï¸ Setting up environment..."
if [ ! -f .env ]; then
  if [ -f .env.test ]; then
    cp .env.test .env
  else
    echo "DATABASE_URL=postgresql://username:password@127.0.0.1:5432/flexile_development" > .env
    echo "REDIS_URL=redis://localhost:6389/0" >> .env
    echo "SIDEKIQ_REDIS_URL=redis://localhost:6389/1" >> .env
    echo "S3_PRIVATE_BUCKET=flexile-development-private" >> .env
    echo "S3_PUBLIC_BUCKET=flexile-development-public" >> .env
    echo "AWS_ENDPOINT_URL=http://localhost:9000" >> .env
    echo "AWS_ACCESS_KEY_ID=minioadmin" >> .env
    echo "AWS_SECRET_ACCESS_KEY=minioadmin123" >> .env
    echo "AWS_REGION=us-east-1" >> .env
  fi
  echo "ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY=$(openssl rand -hex 32)" >> .env
  echo "ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY=$(openssl rand -hex 32)" >> .env
  echo "ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT=$(openssl rand -hex 32)" >> .env
fi

# Link frontend env
ln -sf $PWD/.env ./frontend/.env

# Setup MinIO buckets
echo "ğŸª£ Setting up MinIO..."
mise run minio:setup

echo "âœ… Setup complete! Run 'mise run dev' to start the application."
"""

[tasks.dev]
alias = "start"
description = "ğŸš€ Start development server - replaces bin/dev"
depends = ["docker:up"]
run = """
#!/usr/bin/env bash
set -e

# Check environment
if [ ! -f ".env" ]; then
    echo ".env file not found. Please run 'mise run setup' first."
    exit 1
fi

# Ensure mise Ruby is used (override RVM)
echo "ğŸ’ Setting up Ruby environment..."
export PATH="$(mise where ruby)/bin:$PATH"
unset GEM_HOME GEM_PATH RUBY_VERSION
unset -f rvm >/dev/null 2>&1 || true
eval "$(mise env --shell bash)"

# Install dependencies if needed
echo "ğŸ“¦ Installing Node.js dependencies..."
pnpm install

# Generate SSL certificates
echo "ğŸ” Generating SSL certificates..."
mkdir -p certificates
NODE_EXTRA_CA_CERTS_FILE="$(node docker/createCertificate.js)"

# Generate combined SSL certificates
mkdir -p tmp
default_cert_file=$(ruby -ropenssl -e 'puts OpenSSL::X509::DEFAULT_CERT_FILE')
combined_cert_file="tmp/combined_ca_certs.pem"

if [ -f "$default_cert_file" ] && [ -f "$NODE_EXTRA_CA_CERTS_FILE" ]; then
  cat "$default_cert_file" "$NODE_EXTRA_CA_CERTS_FILE" > "$combined_cert_file"
  echo "Combined certificates created at $combined_cert_file"
  export SSL_CERT_FILE="$(pwd)/$combined_cert_file"
  export NODE_EXTRA_CA_CERTS="$(pwd)/$combined_cert_file"
else
  echo "Warning: Could not create combined cert file. Using default certificates."
fi

# Prepare backend
echo "ğŸ”§ Preparing backend..."
cd backend
bundle install
echo "ğŸ—„ï¸ Preparing database..."
bin/rails db:prepare
cd ..

# Clean up existing processes
echo "ğŸ§¹ Cleaning up existing processes..."
pkill -f "rails.*server" || true
pkill -f "node.*next" || true
pkill -f "sidekiq" || true
lsof -ti:3000 | xargs kill -9 2>/dev/null || true
lsof -ti:3001 | xargs kill -9 2>/dev/null || true
lsof -ti:8288 | xargs kill -9 2>/dev/null || true
rm -f backend/tmp/pids/server.pid

echo "ğŸš€ Starting application services..."
export SSL_CERT_FILE NODE_EXTRA_CA_CERTS PATH
foreman start -f Procfile.dev "$@"
"""

[tasks."dev:test"]
alias = "test-server"
description = "ğŸ§ª Start test server - replaces bin/test_server"
env = { NODE_TLS_REJECT_UNAUTHORIZED = "0", RAILS_ENV = "test", NODE_ENV = "test", ENABLE_DEFAULT_OTP = "true" }
run = """
#!/usr/bin/env bash
set -e

echo "ğŸ§ª Starting test server..."

# Clean up existing processes
pkill -f "rails.*server" || true
pkill -f "node.*next" || true
lsof -ti:3100 | xargs kill -9 2>/dev/null || true
lsof -ti:3101 | xargs kill -9 2>/dev/null || true
lsof -ti:3037 | xargs kill -9 2>/dev/null || true
lsof -ti:8298 | xargs kill -9 2>/dev/null || true

# Setup test database
cd backend
bundle exec rails db:drop db:create db:schema:load db:seed_test_data
cd ..

foreman start -f Procfile.test -e .env.test
"""

# === DEPENDENCY MANAGEMENT ===

[tasks."deps:install"]
description = "ğŸ“¦ Install all dependencies"
run = """
#!/usr/bin/env bash
echo "ğŸ“¦ Installing backend dependencies..."
cd backend && bundle install && gem install foreman && cd ..
echo "ğŸ“¦ Installing frontend dependencies..."
cd frontend && pnpm install && cd ..
echo "âœ… All dependencies installed!"
"""

[tasks."deps:update"]
description = "â¬†ï¸ Update all dependencies"
run = """
#!/usr/bin/env bash
echo "â¬†ï¸ Updating backend dependencies..."
cd backend && bundle update && cd ..
echo "â¬†ï¸ Updating frontend dependencies..."
cd frontend && pnpm update && cd ..
echo "âœ… All dependencies updated!"
"""

[tasks."deps:audit"]
description = "ğŸ” Audit dependencies for security issues"
run = """
#!/usr/bin/env bash
echo "ğŸ” Auditing backend dependencies..."
cd backend && bundle audit && cd ..
echo "ğŸ” Auditing frontend dependencies..."
cd frontend && pnpm audit && cd ..
"""

# === DOCKER SERVICES ===

[tasks."docker:up"]
alias = "services"
description = "ğŸ³ Start Docker services (PostgreSQL, Redis, Nginx, MinIO)"
run = """
#!/usr/bin/env bash
echo "ğŸ³ Starting Docker services..."
mkdir -p docker/tmp/postgres docker/tmp/redis docker/tmp/minio
node docker/createCertificate.js
COMPOSE_PROJECT_NAME=flexile docker compose -f docker/docker-compose-local-linux.yml up -d
echo "â³ Waiting for MinIO to be ready..."
sleep 5
echo "âœ… Docker services started!"
"""

[tasks."docker:down"]
description = "ğŸ³ Stop Docker services"
run = """
#!/usr/bin/env bash
echo "ğŸ³ Stopping Docker services..."
COMPOSE_PROJECT_NAME=flexile docker compose -f docker/docker-compose-local-linux.yml down
echo "âœ… Docker services stopped!"
"""

[tasks."docker:logs"]
description = "ğŸ“‹ Show Docker service logs"
run = "COMPOSE_PROJECT_NAME=flexile docker compose -f docker/docker-compose-local-linux.yml logs -f"

[tasks."docker:reset"]
description = "ğŸ”„ Reset Docker services (stop, remove volumes, start)"
run = """
#!/usr/bin/env bash
echo "ğŸ”„ Resetting Docker services..."
COMPOSE_PROJECT_NAME=flexile docker compose -f docker/docker-compose-local-linux.yml down -v
mise run docker:up
mise run minio:setup
echo "âœ… Docker services reset!"
"""

# === MINIO S3 STORAGE ===

[tasks."minio:setup"]
description = "ğŸª£ Setup MinIO and create required buckets"
depends = ["docker:up"]
run = """
#!/usr/bin/env bash
echo "ğŸª£ Setting up MinIO buckets..."

# Wait for MinIO to be fully ready
echo "â³ Waiting for MinIO to be ready..."
for i in {1..30}; do
  if curl -sf http://localhost:9000/minio/health/live > /dev/null 2>&1; then
    echo "âœ… MinIO is ready!"
    break
  fi
  echo "Waiting... ($i/30)"
  sleep 2
done

# Install MinIO client if not available
if ! command -v mc &> /dev/null; then
  echo "ğŸ“¦ Installing MinIO client..."
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    curl -O https://dl.min.io/client/mc/release/linux-amd64/mc
    chmod +x mc
    sudo mv mc /usr/local/bin/
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    brew install minio/stable/mc
  else
    echo "âŒ Please install MinIO client manually: https://min.io/docs/minio/linux/reference/minio-mc.html"
    exit 1
  fi
fi

# Configure MinIO client
echo "âš™ï¸ Configuring MinIO client..."
mc alias set local http://localhost:9000 minioadmin minioadmin123

# Create buckets
echo "ğŸª£ Creating development buckets..."
mc mb local/flexile-development-private --ignore-existing
mc mb local/flexile-development-public --ignore-existing

# Set bucket policies
echo "ğŸ” Setting bucket policies..."
mc anonymous set download local/flexile-development-public
mc anonymous set none local/flexile-development-private

echo "âœ… MinIO setup complete!"
echo "ğŸ“Š MinIO Console: http://localhost:9001 (minioadmin/minioadmin123)"
echo "ğŸ”— MinIO API: http://localhost:9000"
"""

[tasks."minio:buckets"]
description = "ğŸ“‹ List all MinIO buckets"
run = """
#!/usr/bin/env bash
echo "ğŸ“‹ MinIO buckets:"
mc ls local/
"""

[tasks."minio:console"]
description = "ğŸŒ Open MinIO web console"
run = """
#!/usr/bin/env bash
echo "ğŸŒ Opening MinIO console..."
echo "URL: http://localhost:9001"
echo "Username: minioadmin"
echo "Password: minioadmin123"
if command -v open &> /dev/null; then
  open http://localhost:9001
elif command -v xdg-open &> /dev/null; then
  xdg-open http://localhost:9001
else
  echo "Please open http://localhost:9001 in your browser"
fi
"""

[tasks."minio:status"]
description = "ğŸ“Š Check MinIO service status"
run = """
#!/usr/bin/env bash
echo "ğŸ“Š MinIO Status:"
if curl -sf http://localhost:9000/minio/health/live > /dev/null 2>&1; then
  echo "âœ… MinIO API is running (http://localhost:9000)"
else
  echo "âŒ MinIO API is not responding"
fi

if curl -sf http://localhost:9001 > /dev/null 2>&1; then
  echo "âœ… MinIO Console is running (http://localhost:9001)"
else
  echo "âŒ MinIO Console is not responding"
fi

echo "\\nğŸ“‹ Buckets:"
mc ls local/ 2>/dev/null || echo "âŒ Cannot connect to MinIO"
"""

[tasks."minio:clean"]
description = "ğŸ§¹ Clean all MinIO data and buckets"
confirm = "This will delete all MinIO data. Are you sure?"
run = """
#!/usr/bin/env bash
echo "ğŸ§¹ Cleaning MinIO data..."
mc rm --recursive --force local/flexile-development-private/ 2>/dev/null || true
mc rm --recursive --force local/flexile-development-public/ 2>/dev/null || true
mc rb local/flexile-development-private --force 2>/dev/null || true
mc rb local/flexile-development-public --force 2>/dev/null || true
echo "âœ… MinIO data cleaned!"
"""

[tasks."s3:test"]
description = "ğŸ§ª Test S3 compatibility with sample file"
depends = ["minio:setup"]
run = """
#!/usr/bin/env bash
echo "ğŸ§ª Testing S3 compatibility..."

# Create test file
echo "Hello from Flexile MinIO test!" > /tmp/test-file.txt

# Upload to private bucket
echo "ğŸ“¤ Uploading to private bucket..."
mc cp /tmp/test-file.txt local/flexile-development-private/test-file.txt

# Upload to public bucket
echo "ğŸ“¤ Uploading to public bucket..."
mc cp /tmp/test-file.txt local/flexile-development-public/test-file.txt

# List files
echo "ğŸ“‹ Files in buckets:"
echo "Private bucket:"
mc ls local/flexile-development-private/
echo "Public bucket:"
mc ls local/flexile-development-public/

# Test download
echo "ğŸ“¥ Testing download..."
mc cp local/flexile-development-private/test-file.txt /tmp/downloaded-file.txt
if diff /tmp/test-file.txt /tmp/downloaded-file.txt > /dev/null; then
  echo "âœ… S3 upload/download test successful!"
else
  echo "âŒ S3 test failed!"
fi

# Cleanup
rm -f /tmp/test-file.txt /tmp/downloaded-file.txt

echo "ğŸ”— Access URLs:"
echo "Private: http://localhost:9000/flexile-development-private/test-file.txt (requires auth)"
echo "Public: http://localhost:9000/flexile-development-public/test-file.txt"
"""

# === DATABASE TASKS ===

[tasks."db:setup"]
description = "ğŸ—„ï¸ Setup and prepare the database"
dir = "backend"
run = "bin/rails db:prepare"

[tasks."db:reset"]
description = "ğŸ”„ Reset database with fresh seed data"
dir = "backend"
run = "bin/rails db:reset"

[tasks."db:migrate"]
description = "â¬†ï¸ Run database migrations"
dir = "backend"
run = "bin/rails db:migrate"

[tasks."db:rollback"]
description = "â¬‡ï¸ Rollback last database migration"
dir = "backend"
run = "bin/rails db:rollback"

[tasks."db:seed"]
description = "ğŸŒ± Seed database with sample data"
dir = "backend"
run = "bin/rails db:seed"

[tasks."db:console"]
alias = "dbconsole"
description = "ğŸ’» Open database console"
dir = "backend"
raw = true
run = "bin/rails dbconsole"

# === TESTING ===

[tasks.test]
alias = "t"
description = "ğŸ§ª Run all tests (Rails specs + Playwright e2e)"
run = """
#!/usr/bin/env bash
echo "ğŸ§ª Running Rails specs..."
cd backend && bundle exec rspec
echo "ğŸ­ Running Playwright e2e tests..."
cd .. && pnpm playwright test
echo "âœ… All tests completed!"
"""

[tasks."test:rails"]
alias = "tr"
description = "ğŸ§ª Run Rails specs only"
dir = "backend"
run = "bundle exec rspec"

[tasks."test:e2e"]
alias = "te"
description = "ğŸ­ Run Playwright end-to-end tests only"
run = "pnpm playwright test"

[tasks."test:watch"]
description = "ğŸ‘€ Run tests in watch mode"
dir = "backend"
run = "bundle exec rspec --format documentation --color --order random"

[tasks."test:coverage"]
description = "ğŸ“Š Generate test coverage report"
dir = "backend"
env = { COVERAGE = "true" }
run = "bundle exec rspec"

# === LINTING & FORMATTING ===

[tasks.lint]
alias = "l"
description = "ğŸ” Run all linting and formatting - replaces bin/lint"
run = """
#!/usr/bin/env bash
set -e

echo "ğŸ” Linting frontend..."
pnpm next lint frontend --fix --max-warnings 0
pnpm tsc -p e2e/tsconfig.json
pnpm eslint --fix --max-warnings 0
pnpm prettier --write '**/*.{css,md,json}' --check '!docker'
pnpm svgo --multipass backend/app/assets/**/*.svg
pnpm svgo --multipass frontend/**/*.svg

echo "ğŸ” Linting backend..."
cd backend
bundle exec rubocop -a
bundle exec erb_lint --lint-all --format compact -a

echo "âœ… All linting completed!"
"""

[tasks."lint:frontend"]
description = "ğŸ” Lint frontend code only"
run = """
#!/usr/bin/env bash
pnpm next lint frontend --fix --max-warnings 0
pnpm tsc -p e2e/tsconfig.json
pnpm eslint --fix --max-warnings 0
pnpm prettier --write '**/*.{css,md,json}' --check '!docker'
"""

[tasks."lint:backend"]
description = "ğŸ” Lint backend code only"
dir = "backend"
run = """
#!/usr/bin/env bash
bundle exec rubocop -a
bundle exec erb_lint --lint-all --format compact -a
"""

[tasks."format"]
description = "âœ¨ Format all code"
run = """
#!/usr/bin/env bash
echo "âœ¨ Formatting frontend..."
pnpm prettier --write '**/*.{js,jsx,ts,tsx,css,md,json}' --ignore-path .gitignore
echo "âœ¨ Formatting backend..."
cd backend && bundle exec rubocop -a
echo "âœ… All code formatted!"
"""

# === CI/CD TASKS ===

[tasks."ci:test"]
description = "ğŸ”„ Run CI test suite"
env = { CI = "true" }
run = """
#!/usr/bin/env bash
set -e
echo "ğŸ”„ Running CI test suite..."
mise run lint
mise run test
echo "âœ… CI tests passed!"
"""

[tasks."release:prepare"]
description = "ğŸš€ Prepare database for release - replaces backend/ci_scripts/release.sh"
dir = "backend"
run = """
#!/usr/bin/env bash
set -euo pipefail

RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[0;33m'
NO_COLOR='\\033[0m'

schema_version=$(bundle exec rails db:version | { grep "^Current version: [0-9]\\+$" || true; } | tr -s ' ' | cut -d ' ' -f3)

if [ -z "$schema_version" ]; then
  echo -e "ğŸ‘€ ${RED} [Release Phase]: Database schema version could not be determined. Does the database exist?${NO_COLOR}\n"
  exit 1
fi

if [ "$schema_version" -eq "0" ]; then
  echo -e "\nâ³ ${YELLOW} [Release Phase]: Loading the database schema.${NO_COLOR}\n"
  bundle exec rails db:schema:load
  echo -e "\nâ³ ${YELLOW} [Release Phase]: Loading seed data.${NO_COLOR}\n"
  bundle exec rails db:seed
else
  echo -e "\nâ³ ${YELLOW} [Release Phase]: Running database migrations.${NO_COLOR}\n"
  bundle exec rails db:migrate
fi

echo -e "\nğŸ‰ ${GREEN} [Release Phase]: Database is up to date.${NO_COLOR}\n"
"""

[tasks."release:deploy"]
description = "ğŸš€ Deploy to production"
confirm = "Are you sure you want to deploy to production?"
depends = ["ci:test"]
run = """
#!/usr/bin/env bash
echo "ğŸš€ Deploying to production..."
# Add your deployment logic here
echo "âœ… Deployment completed!"
"""

# === MAINTENANCE ===

[tasks.clean]
alias = "c"
description = "ğŸ§¹ Clean up temporary files and caches"
run = """
#!/usr/bin/env bash
echo "ğŸ§¹ Cleaning up..."
rm -rf backend/tmp/cache/* || true
rm -rf frontend/.next || true
rm -rf node_modules/.cache || true
rm -rf backend/log/*.log || true
rm -rf tmp/* || true
echo "âœ… Cleanup complete!"
"""

[tasks.doctor]
alias = "check"
description = "ğŸ¥ Check development environment health"
run = """
#!/usr/bin/env bash
echo "ğŸ¥ Checking development environment..."
echo "ğŸ“‹ Mise status:"
mise doctor
echo "\nğŸ³ Docker status:"
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
echo "\nğŸ’ Ruby version:"
ruby --version
echo "\nğŸ“¦ Node version:"
node --version
echo "\nğŸ—„ï¸ Database status:"
cd backend && bin/rails runner "puts 'Database: ' + ActiveRecord::Base.connection.adapter_name + ' (Connected)' rescue puts 'Database: Not connected'"
echo "\nğŸª£ MinIO status:"
mise run minio:status
echo "\nğŸ“Š Environment:"
echo "RAILS_ENV: ${RAILS_ENV:-not set}"
echo "NODE_ENV: ${NODE_ENV:-not set}"
echo "AWS_ENDPOINT_URL: ${AWS_ENDPOINT_URL:-not set}"
echo "S3_PRIVATE_BUCKET: ${S3_PRIVATE_BUCKET:-not set}"
echo "S3_PUBLIC_BUCKET: ${S3_PUBLIC_BUCKET:-not set}"
echo "\nâœ… Health check complete!"
"""

[tasks."logs"]
description = "ğŸ“‹ Show application logs"
run = """
#!/usr/bin/env bash
echo "ğŸ“‹ Application logs:"
echo "\n=== Rails logs ==="
tail -f backend/log/development.log 2>/dev/null || echo "No Rails logs found"
"""

# === RUBY VERSION MANAGEMENT ===

[tasks."ruby:fix"]
description = "ğŸ”§ Fix Ruby version conflicts between RVM and mise"
run = """
#!/usr/bin/env bash
echo "ğŸ”§ Fixing Ruby version conflicts..."

# Disable RVM for this session
unset GEM_HOME GEM_PATH
export PATH="$(mise where ruby)/bin:$PATH"

# Check Ruby version
echo "Current Ruby version: $(ruby --version)"
echo "Expected Ruby version: $(mise current ruby)"

# Reinstall gems with correct Ruby version
echo "ğŸ“¦ Reinstalling gems..."
cd backend
bundle install --redownload
cd ..

echo "âœ… Ruby version conflicts resolved!"
"""

# === USER MANAGEMENT ===

[tasks."user:test"]
description = "ğŸ§ª Test complete user creation API flow"
run = """
#!/usr/bin/env bash
set -ex

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m'

echo -e "${BLUE}ğŸ§ª Testing Complete User Creation API Flow${NC}"

# Test backend connectivity
echo -e "${YELLOW}ğŸ“¡ Testing Backend Connectivity...${NC}"
curl -f http://localhost:3000 -o /dev/null -s || { echo -e "${RED}âŒ Rails backend not running${NC}"; exit 1; }
echo -e "${GREEN}âœ… Rails backend: RUNNING${NC}"

curl -f http://flexile.dev:3001 -o /dev/null -s || { echo -e "${RED}âŒ Frontend not running${NC}"; exit 1; }
echo -e "${GREEN}âœ… Frontend: RUNNING${NC}"

# Generate unique test email
TIMESTAMP=$(date +%s)
TEST_EMAIL="test.${TIMESTAMP}@example.com"
echo -e "${YELLOW}ğŸ“§ Using test email: ${TEST_EMAIL}${NC}"

# Step 1: Send OTP
echo -e "${YELLOW}ğŸ“¤ Step 1: Sending OTP...${NC}"
OTP_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST http://flexile.dev:3001/internal/signup/send_otp \\
    -H "Content-Type: application/json" \\
    -d "{\\"email\\": \\"${TEST_EMAIL}\\"}")

OTP_HTTP_CODE=$(echo $OTP_RESPONSE | tr -d '\\n' | sed -e 's/.*HTTPSTATUS://')
OTP_BODY=$(echo $OTP_RESPONSE | sed -E 's/HTTPSTATUS:[0-9]{3}$//')

[ "$OTP_HTTP_CODE" -eq 200 ] && echo -e "${GREEN}âœ… OTP sent (HTTP $OTP_HTTP_CODE)${NC}" || { echo -e "${RED}âŒ OTP failed (HTTP $OTP_HTTP_CODE): ${OTP_BODY}${NC}"; exit 1; }

# Step 2: Create User
echo -e "${YELLOW}ğŸ“¥ Step 2: Creating user...${NC}"
CREATE_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST http://flexile.dev:3001/internal/signup/verify_and_create \\
    -H "Content-Type: application/json" \\
    -d "{\\"email\\": \\"${TEST_EMAIL}\\", \\"otp_code\\": \\"000000\\"}")

CREATE_HTTP_CODE=$(echo $CREATE_RESPONSE | tr -d '\\n' | sed -e 's/.*HTTPSTATUS://')
CREATE_BODY=$(echo $CREATE_RESPONSE | sed -E 's/HTTPSTATUS:[0-9]{3}$//')

[[ "$CREATE_HTTP_CODE" =~ ^20[01]$ ]] && echo -e "${GREEN}âœ… User created (HTTP $CREATE_HTTP_CODE)${NC}" || echo -e "${RED}âŒ User creation failed (HTTP $CREATE_HTTP_CODE): ${CREATE_BODY}${NC}"

echo -e "${GREEN}âœ… User API flow test complete${NC}"
"""

[tasks."user:list"]
description = "ğŸ‘¥ List all users in the system"
dir = "backend"
run = """
bin/rails runner "
puts 'ğŸ‘¥ Users in system:'
puts '=' * 50
User.all.each_with_index do |user, i|
  puts \\"#{i+1}. #{user.email} (ID: #{user.id}) - Created: #{user.created_at.strftime('%Y-%m-%d %H:%M')}\\"
end
puts '\\nTotal users: ' + User.count.to_s
"
"""

[tasks."user:create"]
description = "â• Create a new user interactively"
dir = "backend"
raw = true
run = """
bin/rails runner "
print 'Enter email: '
email = gets.chomp
print 'Enter password (optional, will use default): '
password = gets.chomp
password = 'password' if password.empty?

user = User.create!(email: email, password: password)
puts \\\"âœ… User created: #{user.email} (ID: #{user.id})\\\"
"
"""

[tasks."user:delete"]
description = "ğŸ—‘ï¸ Delete a user by email"
dir = "backend"
raw = true
run = """
bin/rails runner "
print 'Enter email to delete: '
email = gets.chomp
user = User.find_by(email: email)
if user
  user.destroy!
  puts \\\"âœ… User #{email} deleted\\\"
else
  puts \\\"âŒ User #{email} not found\\\"
end
"
"""

[tasks."user:seed"]
description = "ğŸŒ± Create default test users"
dir = "backend"
run = """
bin/rails runner "
puts 'ğŸŒ± Creating default test users...'

test_users = [
  { email: 'admin@example.com', role: 'admin' },
  { email: 'contractor@example.com', role: 'contractor' },
  { email: 'investor@example.com', role: 'investor' },
  { email: 'test@example.com', role: 'user' }
]

test_users.each do |user_data|
  user = User.find_or_create_by(email: user_data[:email]) do |u|
    u.password = 'password'
  end
  puts \\\"âœ… #{user_data[:role].capitalize}: #{user.email}\\\"
end

puts '\\nğŸ”‘ All users have password: password'
puts 'ğŸ”¢ Default OTP: 000000 (if ENABLE_DEFAULT_OTP=true)'
"
"""

# === UTILITIES ===

[tasks."console"]
alias = "c"
description = "ğŸ’» Open Rails console"
dir = "backend"
raw = true
run = "bin/rails console"

[tasks."routes"]
description = "ğŸ—ºï¸ Show Rails routes"
dir = "backend"
run = "bin/rails routes"

[tasks."credentials:edit"]
description = "ğŸ” Edit Rails credentials"
dir = "backend"
raw = true
run = "bin/rails credentials:edit"
